<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Credits</title>
  <link rel="stylesheet" type="text/css" href="styles.css">
  <style>
    body {
      background-color: #000;
      color: #fff;
    }

    #particles-js {
      position: absolute;
      width: 100%;
      height: 100%;
      background-color: #000;
      background-repeat: no-repeat;
      background-size: cover;
      background-position: 50% 50%;
      z-index: -1;
    }
  </style>
  <script src="QR_image_viewer.js"></script>
  <style>
    body {
      overflow: hidden;
      background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
      font-family: sans-serif;
      position: relative;
    }

    canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }

    .container {
      position: relative;
      z-index: 2;
      color: white;
      text-align: center;
      padding: 2rem;
      font-size: 1.5rem;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
    }

    .container h1 {
      margin-bottom: 1rem;
      font-size: 3rem;
      color: #9c2d97;
    }

    .qr-btn {
      position: fixed;
      bottom: 20px;
      left: 20px;
      z-index: 3;
    }

    .home-button {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 3;
    }

    .stack-container {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 240px;
      pointer-events: none;
      z-index: 1;
    }

    .character {
      position: absolute;
      font-family: 'Courier New', monospace;
      font-weight: bold;
      font-size: 20px;
      color: #4ecdc4;
      text-shadow: 0 0 8px currentColor;
      animation: glow 2s infinite alternate;
    }

    @keyframes glow {
      from {
        opacity: 0.8;
        text-shadow: 0 0 5px currentColor;
      }
      to {
        opacity: 1;
        text-shadow: 0 0 15px currentColor, 0 0 20px currentColor;
      }
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div class="stack-container" id="stackContainer"></div>
<button class="qr-btn" onclick="viewQRImage()">
  <img src="resources/QR.jpeg" alt="QR" class="embedded_QR_photo" />
</button>

  <button class="home-button" onclick="window.location.href='https://tahamohamed2.github.io/dental_instructions/'">الرئيسية</button>
  <div class="container">
    <h1>Credits</h1>
    <p><b>د. طه محمد طه</b></p>
    <p>تم تصميم هذه الصفحة بواسطة د. طه محمد طه بهدف توعية المرضى وتقديم التعليمات اللازمة لتحقيق معدل نجاح أعلى وتقليل المضاعفات على المدى البعيد.</p>
    <p>نهدف من خلال هذه الصفحة إلى تقديم خدمة أفضل للمرضى سواء في العيادات الخاصة أو الجامعات. نرجو منكم مشاركة هذه الصفحة لتحقيق هذا الهدف.</p>
  </div>
  <script>
    const qrImage = new Image();
    qrImage.src = 'resources/tooth_icon.webp';

    const sentence = "Smile it's free";
    let charIndex = 0;

    class Tooth {
      constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.reset();
        this.shattered = false;
      }

      reset() {
        this.x = Math.random() * this.canvas.width;
        this.y = -50;
        this.size = 25 + Math.random() * 35;
        this.speed = 2 + Math.random() * 3;
        this.rotation = Math.random() * Math.PI * 2;
        this.rotationSpeed = (Math.random() - 0.5) * 0.1;
        this.shattered = false;
      }

      update() {
        if (this.shattered) return;

        this.y += this.speed;
        this.rotation += this.rotationSpeed;

        if (this.y > this.canvas.height - 240) {
          this.shatter();
          return false;
        }

        return true;
      }

      draw() {
        if (this.shattered) return;

        this.ctx.save();
        this.ctx.translate(this.x, this.y);
        this.ctx.rotate(this.rotation);

        // Draw the QR logo image
        if (qrImage.complete) {
          this.ctx.drawImage(qrImage, -this.size / 2, -this.size / 2, this.size, this.size);
        }

        this.ctx.restore();
      }

      shatter() {
        this.shattered = true;
        const numPieces = 5; // Limit to 5 pieces

        for (let i = 0; i < numPieces; i++) {
          const char = sentence.charAt(charIndex % sentence.length);
          charIndex++;
          const piece = {
            x: this.x + (Math.random() - 0.5) * this.size,
            y: this.canvas.height - 240,
            char: char,
            color: `hsl(${Math.random() * 360}, 80%, 65%)`,
            opacity: 1,
            velocityY: -2 - Math.random() * 3,
            velocityX: (Math.random() - 0.5) * 4
          };
          shatteredPieces.push(piece);
        }

        // Reset tooth after shattering
        setTimeout(() => this.reset(), 2000 + Math.random() * 3000);
      }
    }

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const stackContainer = document.getElementById('stackContainer');

    let teeth = [];
    let shatteredPieces = [];
    let stackedCharacters = [];

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }

    function init() {
      resizeCanvas();

      // Create initial teeth
      for (let i = 0; i < 12; i++) {
        teeth.push(new Tooth(canvas));
        // Stagger their starting positions
        teeth[i].y = -Math.random() * canvas.height;
      }

      animate();
    }

    function animate() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Update and draw teeth
      teeth.forEach(tooth => {
        if (tooth.update()) {
          tooth.draw();
        }
      });

      // Update and draw shattered pieces
      for (let i = shatteredPieces.length - 1; i >= 0; i--) {
        const piece = shatteredPieces[i];

        piece.y += piece.velocityY;
        piece.x += piece.velocityX;
        piece.velocityY += 0.2; // Gravity
        piece.opacity -= 0.01;

        if (piece.y > canvas.height - 150) {
          // Add to stacked characters when reaching bottom
          addToStack(piece);
          shatteredPieces.splice(i, 1);
        } else if (piece.opacity <= 0 || piece.y > canvas.height) {
          shatteredPieces.splice(i, 1);
        } else {
          ctx.globalAlpha = piece.opacity;
          ctx.fillStyle = piece.color;
          ctx.font = '20px Courier New';
          ctx.fillText(piece.char, piece.x, piece.y);
          ctx.globalAlpha = 1;
        }
      }

      requestAnimationFrame(animate);
    }

    function addToStack(piece) {
      const charElement = document.createElement('div');
      charElement.className = 'character';

      // Reorder letters to form "smile it's free"
      const sentence = " Smile it's free ☺";
      const maxWidth = Math.floor(stackContainer.offsetWidth / 10);
      const maxHeight = 2;
      const index = stackedCharacters.length;
      const x = index % maxWidth;
      const y = Math.floor(index / maxWidth);

      // Calculate position
      charElement.style.left = `${x * 10}px`;
      charElement.style.bottom = `${y * 20}px`;
      charElement.style.opacity = '0';
      charElement.style.transform = 'translateY(20px)';

      // Set character from sentence based on index
      charElement.textContent = sentence.charAt(index % sentence.length);
      charElement.style.color = piece.color;

      stackContainer.appendChild(charElement);
      stackedCharacters.push(charElement);

      // Animate appearance
      setTimeout(() => {
        charElement.style.transition = 'all 0.5s ease';
        charElement.style.opacity = '1';
        charElement.style.transform = 'translateY(0)';
      }, 100);

      // Limit stack size
      if (stackedCharacters.length > maxWidth * maxHeight) {
        const oldChar = stackedCharacters.shift();
        oldChar.style.transition = 'all 0.5s ease';
        oldChar.style.opacity = '0';
        setTimeout(() => oldChar.remove(), 500);
      }
    }

    window.addEventListener('resize', resizeCanvas);
    window.addEventListener('load', init);

    // Add mouse interaction
    canvas.addEventListener('mousemove', (e) => {
      const mouseX = e.clientX;
      const mouseY = e.clientY;

      teeth.forEach(tooth => {
        if (!tooth.shattered) {
          const dx = tooth.x - mouseX;
          const dy = tooth.y - mouseY;
          const distance = Math.sqrt(dx * dx + dy * dy);

          if (distance < 100) {
            tooth.x += dx * 0.02;
            tooth.y += dy * 0.02;
          }
        }
      });
    });
  </script>
</body>
</html>